---
description: "Error handling and logging standards for Laravel. Always use try-catch with detailed logs to facilitate debugging and provide clear error messages to users."
alwaysApply: false
---

# Error Handling & Logging - Laravel Project

## When to Use Try-Catch

**ALWAYS use try-catch** in:
- Controller methods that perform write operations
- Database operations (especially outside transactions)
- File/storage operations
- External API calls
- Queue jobs
- Any operation that can throw exceptions

## Logging Requirements

**MANDATORY logs include:**
1. Clear error description
2. File and line where error occurred
3. Full stack trace
4. Relevant data (IDs, values, request data)
5. User context when available

## Correct Pattern

```php
use Illuminate\Support\Facades\Log;

// ✅ CORRECT - Detailed logging with context
public function update(UpdatePostRequest $request, Post $post)
{
    try {
        DB::transaction(function () use ($request, $post) {
            $post->update($request->validated());
            $post->tags()->sync($request->tags);
        });
        
        return redirect()->route('posts.show', $post)
            ->with('success', 'Post updated successfully');
            
    } catch (\Exception $e) {
        Log::error('Failed to update post', [
            'post_id' => $post->id,
            'user_id' => auth()->id(),
            'request_data' => $request->validated(),
            'error' => $e->getMessage(),
            'file' => $e->getFile(),
            'line' => $e->getLine(),
            'trace' => $e->getTraceAsString(),
        ]);
        
        return back()
            ->withErrors(['error' => 'Failed to update post. Please try again.'])
            ->withInput();
    }
}
```

## Wrong Patterns

```php
// ❌ WRONG - No try-catch, errors bubble up
public function store(Request $request)
{
    $post = Post::create($request->all()); // Can throw exception
    return redirect()->route('posts.index');
}

// ❌ WRONG - Silent failure, no logging
public function update(Request $request, Post $post)
{
    try {
        $post->update($request->all());
    } catch (\Exception $e) {
        // Nothing logged!
        return back()->withErrors(['error' => 'Error']);
    }
}

// ❌ WRONG - Generic error, no context
public function destroy(Post $post)
{
    try {
        $post->delete();
    } catch (\Exception $e) {
        Log::error('Error'); // Not helpful!
        return back()->withErrors(['error' => 'Error']);
    }
}
```

## Log Levels

Use appropriate log levels:

```php
// Critical system errors
Log::critical('Database connection failed', ['error' => $e->getMessage()]);

// Errors that need attention
Log::error('Payment processing failed', ['order_id' => $order->id]);

// Warnings for unusual but handled situations
Log::warning('Email sending delayed', ['recipient' => $email]);

// Informational logs for important events
Log::info('User registered', ['user_id' => $user->id]);

// Debug logs for development
Log::debug('Cache miss', ['key' => $cacheKey]);
```

## Specific Scenarios

### File Upload Errors

```php
public function uploadDocument(Request $request)
{
    try {
        $path = $request->file('document')->store('documents');
        
        Document::create([
            'title' => $request->title,
            'file_path' => $path,
        ]);
        
        return back()->with('success', 'Document uploaded');
        
    } catch (\Exception $e) {
        Log::error('Document upload failed', [
            'filename' => $request->file('document')?->getClientOriginalName(),
            'user_id' => auth()->id(),
            'error' => $e->getMessage(),
            'file' => $e->getFile(),
            'line' => $e->getLine(),
        ]);
        
        // Clean up uploaded file if it exists
        if (isset($path) && Storage::exists($path)) {
            Storage::delete($path);
        }
        
        return back()->withErrors(['document' => 'Failed to upload document']);
    }
}
```

### External API Calls

```php
public function syncWithExternalAPI()
{
    try {
        $response = Http::timeout(30)
            ->retry(3, 1000)
            ->post('https://api.example.com/sync', $data);
        
        if (!$response->successful()) {
            throw new \Exception('API returned error: ' . $response->status());
        }
        
        return $response->json();
        
    } catch (\Exception $e) {
        Log::error('External API sync failed', [
            'endpoint' => 'https://api.example.com/sync',
            'data' => $data,
            'error' => $e->getMessage(),
            'trace' => $e->getTraceAsString(),
        ]);
        
        // Re-throw to let caller handle
        throw new \Exception('Failed to sync with external API: ' . $e->getMessage());
    }
}
```

### Queue Jobs

```php
use Illuminate\Bus\Queueable;
use Illuminate\Queue\InteractsWithQueue;

class ProcessReport implements ShouldQueue
{
    use Queueable, InteractsWithQueue;
    
    public function handle()
    {
        try {
            // Process report logic
            $report = Report::find($this->reportId);
            $report->process();
            
        } catch (\Exception $e) {
            Log::error('Report processing failed', [
                'report_id' => $this->reportId,
                'attempt' => $this->attempts(),
                'error' => $e->getMessage(),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            // Mark job as failed
            $this->fail($e);
        }
    }
    
    public function failed(\Throwable $exception)
    {
        // Handle failed job
        Log::critical('Report processing permanently failed', [
            'report_id' => $this->reportId,
            'exception' => $exception->getMessage(),
        ]);
        
        // Notify admin or update report status
    }
}
```

## Custom Exception Classes

Create custom exceptions for domain-specific errors:

```php
namespace App\Exceptions;

class DocumentProcessingException extends \Exception
{
    public function __construct($message, $documentId = null)
    {
        parent::__construct($message);
        $this->documentId = $documentId;
    }
    
    public function context()
    {
        return [
            'document_id' => $this->documentId,
            'error' => $this->getMessage(),
        ];
    }
}

// Usage
try {
    // Processing logic
} catch (\Exception $e) {
    throw new DocumentProcessingException(
        'Failed to process document',
        $document->id
    );
}
```

## User-Friendly Error Messages

**NEVER** expose technical details to users:

```php
// ✅ GOOD - User-friendly message
return back()->withErrors([
    'error' => 'Failed to save document. Please try again or contact support.'
]);

// ❌ BAD - Technical details exposed
return back()->withErrors([
    'error' => 'SQLSTATE[23000]: Integrity constraint violation'
]);
```

## Error Monitoring Integration

For production, integrate with error monitoring:

```php
// In bootstrap/app.php
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->report(function (\Throwable $e) {
        // Send to error monitoring service (Sentry, Bugsnag, etc.)
        if (app()->bound('sentry')) {
            app('sentry')->captureException($e);
        }
    });
})
```

## Best Practices Summary

1. **Always catch exceptions** in controllers and jobs
2. **Log with full context** - error, trace, relevant IDs
3. **Provide clear user feedback** - don't expose technical details
4. **Clean up on failure** - delete uploaded files, rollback changes
5. **Re-throw when appropriate** - let transactions rollback
6. **Use custom exceptions** - for domain-specific errors
7. **Monitor production errors** - integrate with monitoring tools
